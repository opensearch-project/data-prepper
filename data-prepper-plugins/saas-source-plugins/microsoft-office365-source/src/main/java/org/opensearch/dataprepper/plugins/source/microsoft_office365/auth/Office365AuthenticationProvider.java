/*
 * Copyright OpenSearch Contributors
 * SPDX-License-Identifier: Apache-2.0
 *
 * The OpenSearch Contributors require contributions made to
 * this file be licensed under the Apache-2.0 license or a
 * compatible open source license.
 */

package org.opensearch.dataprepper.plugins.source.microsoft_office365.auth;

import lombok.Getter;
import org.opensearch.dataprepper.plugins.source.microsoft_office365.Office365SourceConfig;
import org.opensearch.dataprepper.plugins.source.source_crawler.exception.SaaSCrawlerException;
import org.opensearch.dataprepper.plugins.source.source_crawler.metrics.VendorAPIMetricsRecorder;
import org.opensearch.dataprepper.plugins.source.source_crawler.utils.retry.RetryHandler;
import org.opensearch.dataprepper.plugins.source.source_crawler.utils.retry.DefaultRetryStrategy;
import org.opensearch.dataprepper.plugins.source.source_crawler.utils.retry.DefaultStatusCodeHandler;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.client.RestTemplate;
import org.springframework.util.StringUtils;

import javax.inject.Named;
import java.time.Instant;
import java.util.Map;
import java.util.concurrent.atomic.AtomicBoolean;

/**
 * OAuth2 implementation of the Office365AuthProvider.
 */
@Named
public class Office365AuthenticationProvider implements Office365AuthenticationInterface {
    private static final Logger log = LoggerFactory.getLogger(Office365AuthenticationProvider.class);
    private static final String TOKEN_URL = "https://login.microsoftonline.com/%s/oauth2/v2.0/token";
    private static final String MANAGEMENT_API_SCOPE = "https://manage.office.com/.default";
    private static final String ACCESS_TOKEN_REQUEST_BODY = "grant_type=client_credentials" +
            "&client_id=%s" +
            "&client_secret=%s" +
            "&scope=%s";
    
    private final RestTemplate restTemplate = new RestTemplate();
    private final RetryHandler retryHandler;
    private final String tenantId;
    private final Office365SourceConfig office365SourceConfig;
    private final VendorAPIMetricsRecorder metricsRecorder;
    private String accessToken;
    private final Object lock = new Object();
    private final Object accessTokenFetchLock = new Object();
    private final AtomicBoolean credentialsInitialized = new AtomicBoolean(false);

    @Getter
    private Instant expireTime = Instant.ofEpochMilli(0);

    public Office365AuthenticationProvider(Office365SourceConfig config, VendorAPIMetricsRecorder metricsRecorder) {
        this.tenantId = config.getTenantId();
        this.office365SourceConfig = config;
        this.retryHandler = new RetryHandler(
                new DefaultRetryStrategy(),
                new DefaultStatusCodeHandler());
        this.metricsRecorder = metricsRecorder;
    }

    @Override
    public String getTenantId() {
        return this.tenantId;
    }

    @Override
    public void renewCredentials() {
        synchronized(lock) {
            log.info("Getting new access token for Office 365 Management API");

            HttpHeaders headers = new HttpHeaders();
            headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);

            Oauth2Config oAuthConfig = office365SourceConfig.getAuthenticationConfiguration().getOauth2();
            oAuthConfig.getClientId().refresh();
            oAuthConfig.getClientSecret().refresh();
            String payload = String.format(ACCESS_TOKEN_REQUEST_BODY, (String) oAuthConfig.getClientId().getValue(), (String) oAuthConfig.getClientSecret().getValue(), MANAGEMENT_API_SCOPE);

            HttpEntity<String> entity = new HttpEntity<>(payload, headers);
            String tokenEndpoint = String.format(TOKEN_URL, office365SourceConfig.getTenantId());

            try {
                // Record authentication latency and execute the request
                ResponseEntity<Map> response = metricsRecorder.recordAuthLatency(() -> 
                    retryHandler.executeWithRetry(
                        () -> restTemplate.postForEntity(tokenEndpoint, entity, Map.class),
                        () -> {
                        } // No credential renewal for authentication endpoint
                    )
                );

                Map<String, Object> tokenResponse = response.getBody();

                if (tokenResponse == null || tokenResponse.get("access_token") == null) {
                    throw new SaaSCrawlerException("Invalid token response: missing access_token", false);
                }

                this.accessToken = (String) tokenResponse.get("access_token");
                int expiresIn = (int) tokenResponse.get("expires_in");
                this.expireTime = Instant.now().plusSeconds(expiresIn);
                
                // Record successful authentication
                metricsRecorder.recordAuthSuccess();
                
                log.info("Received new access token. Expires in {} seconds", expiresIn);
            } catch (Exception e) {
                // Record authentication failure and specific error details
                metricsRecorder.recordAuthFailure();
                metricsRecorder.recordError(e);
                log.error("Failed to renew Office 365 credentials", e);
                throw e;
            }
        }
    }

    @Override
    public String getAccessToken() {
        if (!StringUtils.hasLength(accessToken)) {
            synchronized (accessTokenFetchLock) {
                if (!StringUtils.hasLength(accessToken)) {
                    initCredentials();
                }
            }
        }
        return accessToken;
    }

    @Override
    public boolean isCredentialsInitialized() {
        return credentialsInitialized.get();
    }

    @Override
    public void setCredentialsInitialized(boolean initialized) {
        credentialsInitialized.set(initialized);
    }
}
